import {
  __toESM,
  require_react
} from "./chunk-ZGXIFTAB.js";

// node_modules/react-location/build/esm/index.js
var React = __toESM(require_react());
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var r;
var B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
var C = true ? function(b) {
  return Object.freeze(b);
} : function(b) {
  return b;
};
function D(b, h) {
  if (!b) {
    typeof console !== "undefined" && console.warn(h);
    try {
      throw Error(h);
    } catch (k) {
    }
  }
}
function E(b) {
  b.preventDefault();
  b.returnValue = "";
}
function F() {
  var b = [];
  return { get length() {
    return b.length;
  }, push: function(h) {
    b.push(h);
    return function() {
      b = b.filter(function(k) {
        return k !== h;
      });
    };
  }, call: function(h) {
    b.forEach(function(k) {
      return k && k(h);
    });
  } };
}
function H() {
  return Math.random().toString(36).substr(2, 8);
}
function I(b) {
  var h = b.pathname, k = b.search;
  b = b.hash;
  return (h === void 0 ? "/" : h) + (k === void 0 ? "" : k) + (b === void 0 ? "" : b);
}
function J(b) {
  var h = {};
  if (b) {
    var k = b.indexOf("#");
    0 <= k && (h.hash = b.substr(k), b = b.substr(0, k));
    k = b.indexOf("?");
    0 <= k && (h.search = b.substr(k), b = b.substr(0, k));
    b && (h.pathname = b);
  }
  return h;
}
function createBrowserHistory(b) {
  function h() {
    var c = p.location, a = m.state || {};
    return [a.idx, C({ pathname: c.pathname, search: c.search, hash: c.hash, state: a.usr || null, key: a.key || "default" })];
  }
  function k(c) {
    return typeof c === "string" ? c : I(c);
  }
  function x(c, a) {
    a === void 0 && (a = null);
    return C(_extends({}, q, typeof c === "string" ? J(c) : c, { state: a, key: H() }));
  }
  function z(c) {
    t = c;
    c = h();
    v = c[0];
    q = c[1];
    d.call({ action: t, location: q });
  }
  function A(c, a) {
    function e() {
      A(c, a);
    }
    var l = r.Push, g = x(c, a);
    if (!f.length || (f.call({
      action: l,
      location: g,
      retry: e
    }), false)) {
      var n = [{ usr: g.state, key: g.key, idx: v + 1 }, k(g)];
      g = n[0];
      n = n[1];
      try {
        m.pushState(g, "", n);
      } catch (G) {
        p.location.assign(n);
      }
      z(l);
    }
  }
  function y(c, a) {
    function e() {
      y(c, a);
    }
    var l = r.Replace, g = x(c, a);
    f.length && (f.call({ action: l, location: g, retry: e }), 1) || (g = [{ usr: g.state, key: g.key, idx: v }, k(g)], m.replaceState(g[0], "", g[1]), z(l));
  }
  function w(c) {
    m.go(c);
  }
  b === void 0 && (b = {});
  b = b.window;
  var p = b === void 0 ? document.defaultView : b, m = p.history, u = null;
  p.addEventListener("popstate", function() {
    if (u)
      f.call(u), u = null;
    else {
      var c = r.Pop, a = h(), e = a[0];
      a = a[1];
      if (f.length)
        if (e != null) {
          var l = v - e;
          l && (u = { action: c, location: a, retry: function() {
            w(-1 * l);
          } }, w(l));
        } else
          true ? D(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
      else
        z(c);
    }
  });
  var t = r.Pop;
  b = h();
  var v = b[0], q = b[1], d = F(), f = F();
  v == null && (v = 0, m.replaceState(_extends({}, m.state, { idx: v }), ""));
  return { get action() {
    return t;
  }, get location() {
    return q;
  }, createHref: k, push: A, replace: y, go: w, back: function() {
    w(-1);
  }, forward: function() {
    w(1);
  }, listen: function(c) {
    return d.push(c);
  }, block: function(c) {
    var a = f.push(c);
    f.length === 1 && p.addEventListener("beforeunload", E);
    return function() {
      a();
      f.length || p.removeEventListener("beforeunload", E);
    };
  } };
}
function createHashHistory(b) {
  function h() {
    var a = J(m.location.hash.substr(1)), e = a.pathname, l = a.search;
    a = a.hash;
    var g = u.state || {};
    return [g.idx, C({ pathname: e === void 0 ? "/" : e, search: l === void 0 ? "" : l, hash: a === void 0 ? "" : a, state: g.usr || null, key: g.key || "default" })];
  }
  function k() {
    if (t)
      c.call(t), t = null;
    else {
      var a = r.Pop, e = h(), l = e[0];
      e = e[1];
      if (c.length)
        if (l != null) {
          var g = q - l;
          g && (t = { action: a, location: e, retry: function() {
            p(-1 * g);
          } }, p(g));
        } else
          true ? D(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
      else
        A(a);
    }
  }
  function x(a) {
    var e = document.querySelector("base"), l = "";
    e && e.getAttribute("href") && (e = m.location.href, l = e.indexOf("#"), l = l === -1 ? e : e.slice(0, l));
    return l + "#" + (typeof a === "string" ? a : I(a));
  }
  function z(a, e) {
    e === void 0 && (e = null);
    return C(_extends({}, d, typeof a === "string" ? J(a) : a, { state: e, key: H() }));
  }
  function A(a) {
    v = a;
    a = h();
    q = a[0];
    d = a[1];
    f.call({ action: v, location: d });
  }
  function y(a, e) {
    function l() {
      y(a, e);
    }
    var g = r.Push, n = z(a, e);
    true ? D(n.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(a) + ")") : void 0;
    if (!c.length || (c.call({ action: g, location: n, retry: l }), false)) {
      var G = [{ usr: n.state, key: n.key, idx: q + 1 }, x(n)];
      n = G[0];
      G = G[1];
      try {
        u.pushState(n, "", G);
      } catch (K) {
        m.location.assign(G);
      }
      A(g);
    }
  }
  function w(a, e) {
    function l() {
      w(a, e);
    }
    var g = r.Replace, n = z(a, e);
    true ? D(n.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(a) + ")") : void 0;
    c.length && (c.call({
      action: g,
      location: n,
      retry: l
    }), 1) || (n = [{ usr: n.state, key: n.key, idx: q }, x(n)], u.replaceState(n[0], "", n[1]), A(g));
  }
  function p(a) {
    u.go(a);
  }
  b === void 0 && (b = {});
  b = b.window;
  var m = b === void 0 ? document.defaultView : b, u = m.history, t = null;
  m.addEventListener("popstate", k);
  m.addEventListener("hashchange", function() {
    var a = h()[1];
    I(a) !== I(d) && k();
  });
  var v = r.Pop;
  b = h();
  var q = b[0], d = b[1], f = F(), c = F();
  q == null && (q = 0, u.replaceState(_extends({}, u.state, { idx: q }), ""));
  return {
    get action() {
      return v;
    },
    get location() {
      return d;
    },
    createHref: x,
    push: y,
    replace: w,
    go: p,
    back: function() {
      p(-1);
    },
    forward: function() {
      p(1);
    },
    listen: function(a) {
      return f.push(a);
    },
    block: function(a) {
      var e = c.push(a);
      c.length === 1 && m.addEventListener("beforeunload", E);
      return function() {
        e();
        c.length || m.removeEventListener("beforeunload", E);
      };
    }
  };
}
function createMemoryHistory(b) {
  function h(d, f) {
    f === void 0 && (f = null);
    return C(_extends({}, t, typeof d === "string" ? J(d) : d, { state: f, key: H() }));
  }
  function k(d, f, c) {
    return !q.length || (q.call({ action: d, location: f, retry: c }), false);
  }
  function x(d, f) {
    u = d;
    t = f;
    v.call({ action: u, location: t });
  }
  function z(d, f) {
    var c = r.Push, a = h(d, f);
    true ? D(t.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(d) + ")") : void 0;
    k(c, a, function() {
      z(d, f);
    }) && (m += 1, p.splice(m, p.length, a), x(c, a));
  }
  function A(d, f) {
    var c = r.Replace, a = h(d, f);
    true ? D(t.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(d) + ")") : void 0;
    k(c, a, function() {
      A(d, f);
    }) && (p[m] = a, x(c, a));
  }
  function y(d) {
    var f = Math.min(Math.max(m + d, 0), p.length - 1), c = r.Pop, a = p[f];
    k(c, a, function() {
      y(d);
    }) && (m = f, x(c, a));
  }
  b === void 0 && (b = {});
  var w = b;
  b = w.initialEntries;
  w = w.initialIndex;
  var p = (b === void 0 ? ["/"] : b).map(function(d) {
    var f = C(_extends({ pathname: "/", search: "", hash: "", state: null, key: H() }, typeof d === "string" ? J(d) : d));
    true ? D(f.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(d) + ")") : void 0;
    return f;
  }), m = Math.min(Math.max(w == null ? p.length - 1 : w, 0), p.length - 1), u = r.Pop, t = p[m], v = F(), q = F();
  return { get index() {
    return m;
  }, get action() {
    return u;
  }, get location() {
    return t;
  }, createHref: function(d) {
    return typeof d === "string" ? d : I(d);
  }, push: z, replace: A, go: y, back: function() {
    y(-1);
  }, forward: function() {
    y(1);
  }, listen: function(d) {
    return v.push(d);
  }, block: function(d) {
    return q.push(d);
  } };
}
var _excluded = ["children", "location"];
var _excluded2 = ["location"];
var _excluded3 = ["basepath", "routes"];
var _excluded4 = ["to", "search", "hash", "children", "target", "style", "replace", "onClick", "onMouseEnter", "className", "getActiveProps", "getInactiveProps", "activeOptions", "preload", "disabled", "_ref"];
var _excluded5 = ["style", "className"];
var _excluded6 = ["style", "className"];
var _excluded7 = ["pending"];
var _excluded8 = ["children"];
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function _empty() {
}
function _continueIgnored(value) {
  if (value && value.then) {
    return value.then(_empty);
  }
}
function _async(f) {
  return function() {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
var LocationContext = React.createContext(null);
var MatchesContext = React.createContext(null);
var routerContext = React.createContext(null);
var isDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var useLayoutEffect2 = isDOM ? React.useLayoutEffect : React.useEffect;
var createDefaultHistory = function createDefaultHistory2() {
  return isDOM ? createBrowserHistory() : createMemoryHistory();
};
var Subscribable = function() {
  function Subscribable2() {
    this.listeners = [];
  }
  var _proto = Subscribable2.prototype;
  _proto.subscribe = function subscribe(listener) {
    var _this = this;
    this.listeners.push(listener);
    return function() {
      _this.listeners = _this.listeners.filter(function(x) {
        return x !== listener;
      });
    };
  };
  _proto.notify = function notify() {
    this.listeners.forEach(function(listener) {
      return listener();
    });
  };
  return Subscribable2;
}();
var ReactLocation = function(_Subscribable) {
  _inheritsLoose(ReactLocation2, _Subscribable);
  function ReactLocation2(options) {
    var _options$stringifySea, _options$parseSearch;
    var _this2;
    _this2 = _Subscribable.call(this) || this;
    _this2.isTransitioning = false;
    _this2.history = (options == null ? void 0 : options.history) || createDefaultHistory();
    _this2.stringifySearch = (_options$stringifySea = options == null ? void 0 : options.stringifySearch) != null ? _options$stringifySea : defaultStringifySearch;
    _this2.parseSearch = (_options$parseSearch = options == null ? void 0 : options.parseSearch) != null ? _options$parseSearch : defaultParseSearch;
    _this2.current = _this2.parseLocation(_this2.history.location);
    _this2.destroy = _this2.history.listen(function(event) {
      _this2.current = _this2.parseLocation(event.location, _this2.current);
      _this2.notify();
    });
    return _this2;
  }
  var _proto2 = ReactLocation2.prototype;
  _proto2.buildNext = function buildNext(basepath, dest) {
    var _dest$to, _ref2, _dest$__searchFilters;
    if (basepath === void 0) {
      basepath = "/";
    }
    if (dest === void 0) {
      dest = {};
    }
    var from = _extends$1({}, this.current, dest.from);
    var pathname = resolvePath(basepath, from.pathname, "" + ((_dest$to = dest.to) != null ? _dest$to : "."));
    var updatedSearch = (_ref2 = dest.search === true ? from.search : functionalUpdate(dest.search, from.search)) != null ? _ref2 : {};
    var filteredSearch = (_dest$__searchFilters = dest.__searchFilters) != null && _dest$__searchFilters.length ? dest.__searchFilters.reduce(function(prev, next) {
      return next(prev, updatedSearch);
    }, from.search) : updatedSearch;
    var search = replaceEqualDeep(from.search, filteredSearch);
    var searchStr = this.stringifySearch(search);
    var hash = functionalUpdate(dest.hash, from.hash);
    hash = hash ? "#" + hash : "";
    return {
      pathname,
      search,
      searchStr,
      hash,
      href: "" + pathname + searchStr + hash,
      key: dest.key
    };
  };
  _proto2.navigate = function navigate(next, replace) {
    var _this3 = this;
    this.current = next;
    if (this.navigateTimeout)
      clearTimeout(this.navigateTimeout);
    var nextAction = "replace";
    if (!this.nextAction) {
      nextAction = replace ? "replace" : "push";
    }
    if (!replace) {
      nextAction = "push";
    }
    this.nextAction = nextAction;
    this.navigateTimeout = setTimeout(function() {
      var nextAction2 = _this3.nextAction;
      delete _this3.nextAction;
      var isSameUrl = _this3.parseLocation(_this3.history.location).href === _this3.current.href;
      if (isSameUrl && !_this3.current.key) {
        nextAction2 = "replace";
      }
      if (nextAction2 === "replace") {
        return _this3.history.replace({
          pathname: _this3.current.pathname,
          hash: _this3.current.hash,
          search: _this3.current.searchStr
        });
      }
      return _this3.history.push({
        pathname: _this3.current.pathname,
        hash: _this3.current.hash,
        search: _this3.current.searchStr
      });
    }, 16);
  };
  _proto2.parseLocation = function parseLocation(location, previousLocation) {
    var _location$hash$split$;
    var parsedSearch = this.parseSearch(location.search);
    return {
      pathname: location.pathname,
      searchStr: location.search,
      search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
      hash: (_location$hash$split$ = location.hash.split("#").reverse()[0]) != null ? _location$hash$split$ : "",
      href: "" + location.pathname + location.search + location.hash,
      key: location.key
    };
  };
  return ReactLocation2;
}(Subscribable);
function MatchesProvider(props) {
  return React.createElement(MatchesContext.Provider, props);
}
function Router(_ref3) {
  var children = _ref3.children, location = _ref3.location, rest = _objectWithoutPropertiesLoose(_ref3, _excluded);
  var routerRef = React.useRef(null);
  if (!routerRef.current) {
    routerRef.current = new RouterInstance({
      location,
      routes: rest.routes
    });
  }
  var router = routerRef.current;
  var _React$useReducer = React.useReducer(function() {
    return {};
  }, {}), nonce = _React$useReducer[0], rerender = _React$useReducer[1];
  router.update(rest);
  useLayoutEffect2(function() {
    return router.subscribe(function() {
      rerender();
    });
  }, []);
  useLayoutEffect2(function() {
    return router.updateLocation(location.current).unsubscribe;
  }, [location.current.key]);
  var routerValue = React.useMemo(function() {
    return {
      router
    };
  }, [nonce]);
  return React.createElement(LocationContext.Provider, {
    value: {
      location
    }
  }, React.createElement(routerContext.Provider, {
    value: routerValue
  }, React.createElement(MatchesProvider, {
    value: [router.rootMatch].concat(router.state.matches)
  }, children != null ? children : React.createElement(Outlet, null))));
}
var RouterInstance = function(_Subscribable2) {
  _inheritsLoose(RouterInstance2, _Subscribable2);
  function RouterInstance2(_ref4) {
    var _this4;
    var location = _ref4.location, rest = _objectWithoutPropertiesLoose(_ref4, _excluded2);
    _this4 = _Subscribable2.call(this) || this;
    _this4.routesById = {};
    _this4.update = function(_ref5) {
      var basepath = _ref5.basepath, routes = _ref5.routes, opts = _objectWithoutPropertiesLoose(_ref5, _excluded3);
      Object.assign(_assertThisInitialized(_this4), opts);
      _this4.basepath = cleanPath("/" + (basepath != null ? basepath : ""));
      _this4.routesById = {};
      var recurseRoutes = function recurseRoutes2(routes2, parent) {
        return routes2.map(function(route) {
          var _route$path, _route$pendingMs, _route$pendingMinMs, _route$children;
          var path = (_route$path = route.path) != null ? _route$path : "*";
          var id = joinPaths([(parent == null ? void 0 : parent.id) === "root" ? "" : parent == null ? void 0 : parent.id, "" + (path == null ? void 0 : path.replace(/(.)\/$/, "$1")) + (route.id ? "-" + route.id : "")]);
          route = _extends$1({}, route, {
            pendingMs: (_route$pendingMs = route.pendingMs) != null ? _route$pendingMs : opts == null ? void 0 : opts.defaultPendingMs,
            pendingMinMs: (_route$pendingMinMs = route.pendingMinMs) != null ? _route$pendingMinMs : opts == null ? void 0 : opts.defaultPendingMinMs,
            id
          });
          if (_this4.routesById[id]) {
            if (true) {
              console.warn("Duplicate routes found with id: " + id, _this4.routesById, route);
            }
            throw new Error();
          }
          _this4.routesById[id] = route;
          route.children = (_route$children = route.children) != null && _route$children.length ? recurseRoutes2(route.children, route) : void 0;
          return route;
        });
      };
      _this4.routes = recurseRoutes(routes);
      _this4.rootMatch = {
        id: "root",
        params: {},
        search: {},
        pathname: _this4.basepath,
        route: null,
        ownData: {},
        data: {},
        isLoading: false,
        status: "resolved"
      };
    };
    _this4.setState = function(updater) {
      var newState = updater({
        state: _this4.state,
        pending: _this4.pending
      });
      _this4.state = newState.state;
      _this4.pending = newState.pending;
      _this4.cleanMatchCache();
      _this4.notify();
    };
    _this4.matchCache = {};
    _this4.cleanMatchCache = function() {
      var _assertThisInitialize, _assertThisInitialize2, _assertThisInitialize3, _assertThisInitialize4, _assertThisInitialize5;
      var activeMatchIds = [].concat((_assertThisInitialize = (_assertThisInitialize2 = _assertThisInitialized(_this4)) == null ? void 0 : _assertThisInitialize2.state.matches) != null ? _assertThisInitialize : [], (_assertThisInitialize3 = (_assertThisInitialize4 = _assertThisInitialized(_this4)) == null ? void 0 : (_assertThisInitialize5 = _assertThisInitialize4.pending) == null ? void 0 : _assertThisInitialize5.matches) != null ? _assertThisInitialize3 : []).map(function(d) {
        return d.id;
      });
      Object.values(_this4.matchCache).forEach(function(match) {
        var _match$updatedAt;
        if (!match.updatedAt) {
          return;
        }
        if (activeMatchIds.includes(match.id)) {
          return;
        }
        var age = Date.now() - ((_match$updatedAt = match.updatedAt) != null ? _match$updatedAt : 0);
        if (!match.maxAge || age > match.maxAge) {
          if (match.route.unloader) {
            match.route.unloader(match);
          }
          delete _this4.matchCache[match.id];
        }
      });
    };
    _this4.updateLocation = function(next) {
      var unsubscribe;
      var promise = new Promise(function(resolve) {
        var matchLoader = new MatchLoader(_assertThisInitialized(_this4), next);
        _this4.setState(function(old) {
          return _extends$1({}, old, {
            pending: {
              location: matchLoader.location,
              matches: matchLoader.matches
            }
          });
        });
        unsubscribe = matchLoader.subscribe(function() {
          var currentMatches = _this4.state.matches;
          currentMatches.filter(function(d) {
            return !matchLoader.matches.find(function(dd) {
              return dd.id === d.id;
            });
          }).forEach(function(d) {
            d.onExit == null ? void 0 : d.onExit(d);
          });
          currentMatches.filter(function(d) {
            return matchLoader.matches.find(function(dd) {
              return dd.id === d.id;
            });
          }).forEach(function(d) {
            d.route.onTransition == null ? void 0 : d.route.onTransition(d);
          });
          matchLoader.matches.filter(function(d) {
            return !currentMatches.find(function(dd) {
              return dd.id === d.id;
            });
          }).forEach(function(d) {
            d.onExit = d.route.onMatch == null ? void 0 : d.route.onMatch(d);
          });
          _this4.setState(function(old) {
            return _extends$1({}, old, {
              state: {
                location: matchLoader.location,
                matches: matchLoader.matches
              },
              pending: void 0
            });
          });
          resolve();
        });
        matchLoader.loadData();
        matchLoader.startPending();
      });
      return {
        promise,
        unsubscribe
      };
    };
    _this4.update(rest);
    _this4.state = {
      location: location.current,
      matches: []
    };
    location.subscribe(function() {
      return _this4.notify();
    });
    return _this4;
  }
  return RouterInstance2;
}(Subscribable);
function useLocation() {
  var context = React.useContext(LocationContext);
  warning(!!context, "useLocation must be used within a <ReactLocation />");
  return context.location;
}
var RouteMatch = function RouteMatch2(unloadedMatch) {
  var _this5 = this;
  this.status = "loading";
  this.ownData = {};
  this.data = {};
  this.isLoading = false;
  this.notify = function(isSoft) {
    var _this5$matchLoader;
    (_this5$matchLoader = _this5.matchLoader) == null ? void 0 : _this5$matchLoader.preNotify(isSoft);
  };
  this.assignMatchLoader = function(matchLoader) {
    _this5.matchLoader = matchLoader;
  };
  this.startPending = function() {
    if (_this5.pendingTimeout) {
      clearTimeout(_this5.pendingTimeout);
    }
    if (_this5.route.pendingMs !== void 0) {
      _this5.pendingTimeout = setTimeout(function() {
        if (_this5.status === "loading") {
          _this5.status = "pending";
        }
        _this5.notify == null ? void 0 : _this5.notify();
        if (typeof _this5.route.pendingMinMs !== "undefined") {
          _this5.pendingMinPromise = new Promise(function(r2) {
            return setTimeout(r2, _this5.route.pendingMinMs);
          });
        }
      }, _this5.route.pendingMs);
    }
  };
  this.load = function(opts) {
    var _ref6, _opts$maxAge;
    _this5.maxAge = (_ref6 = (_opts$maxAge = opts.maxAge) != null ? _opts$maxAge : _this5.route.loaderMaxAge) != null ? _ref6 : opts.router.defaultLoaderMaxAge;
    if (_this5.loaderPromise) {
      return;
    }
    var importer = _this5.route["import"];
    _this5.loaderPromise = (!importer ? Promise.resolve() : importer({
      params: _this5.params,
      search: _this5.search
    }).then(function(imported) {
      _this5.route = _extends$1({}, _this5.route, imported);
    })).then(function() {
      var elementPromises = [];
      var elementTypes = ["element", "errorElement", "pendingElement"];
      elementTypes.forEach(function(type) {
        var routeElement = _this5.route[type];
        if (_this5[type]) {
          return;
        }
        if (typeof routeElement === "function") {
          elementPromises.push(routeElement(_this5).then(function(res) {
            _this5[type] = res;
          }));
        } else {
          _this5[type] = _this5.route[type];
        }
      });
      var loader = _this5.route.loader;
      var dataPromise = !loader ? Promise.resolve().then(function() {
        _this5.status = "resolved";
      }) : new Promise(_async(function(resolveLoader) {
        var pendingTimeout;
        var resolve = function resolve2(data) {
          _this5.status = "resolved";
          _this5.ownData = data;
          _this5.error = void 0;
        };
        var reject = function reject2(err) {
          console.error(err);
          _this5.status = "rejected";
          _this5.error = err;
        };
        var finish = function finish2() {
          _this5.isLoading = false;
          _this5.startPending = void 0;
          clearTimeout(pendingTimeout);
          resolveLoader(_this5.ownData);
          _this5.notify == null ? void 0 : _this5.notify(true);
        };
        return _continueIgnored(_catch(function() {
          _this5.isLoading = true;
          return _await(loader(_this5, {
            parentMatch: opts.parentMatch,
            dispatch: _async(function(event) {
              if (event.type === "resolve") {
                resolve(event.data);
              } else if (event.type === "reject") {
                reject(event.error);
              } else if (event.type === "loading") {
                _this5.isLoading = true;
              } else if (event.type === "maxAge") {
                _this5.maxAge = event.maxAge;
              }
              _this5.updatedAt = Date.now();
              _this5.notify == null ? void 0 : _this5.notify(true);
              return _await();
            })
          }), function(_loader) {
            resolve(_loader);
            return _await(_this5.pendingMinPromise, function() {
              finish();
            });
          });
        }, function(err) {
          reject(err);
          finish();
        }));
      }));
      return Promise.all([].concat(elementPromises, [dataPromise])).then(function() {
        _this5.updatedAt = Date.now();
      });
    }).then(function() {
      return _this5.ownData;
    });
  };
  Object.assign(this, unloadedMatch);
};
var MatchLoader = function(_Subscribable3) {
  _inheritsLoose(MatchLoader2, _Subscribable3);
  function MatchLoader2(router, nextLocation) {
    var _this6;
    _this6 = _Subscribable3.call(this) || this;
    _this6.status = "pending";
    _this6.preNotify = function(isSoft) {
      if (!isSoft) {
        _this6.status = "resolved";
      }
      cascadeMatchData(_this6.matches);
      _this6.notify();
    };
    _this6.loadData = _async(function(_temp) {
      var _this6$matches;
      var _ref7 = _temp === void 0 ? {} : _temp, maxAge = _ref7.maxAge;
      _this6.router.cleanMatchCache();
      if (!((_this6$matches = _this6.matches) != null && _this6$matches.length)) {
        _this6.preNotify();
        return;
      }
      _this6.firstRenderPromises = [];
      _this6.matches.forEach(function(match, index) {
        var _this6$matches2, _this6$firstRenderPro;
        var parentMatch = (_this6$matches2 = _this6.matches) == null ? void 0 : _this6$matches2[index - 1];
        match.assignMatchLoader == null ? void 0 : match.assignMatchLoader(_assertThisInitialized(_this6));
        match.load == null ? void 0 : match.load({
          maxAge,
          parentMatch,
          router: _this6.router
        });
        (_this6$firstRenderPro = _this6.firstRenderPromises) == null ? void 0 : _this6$firstRenderPro.push(match.loaderPromise);
      });
      return Promise.all(_this6.firstRenderPromises).then(function() {
        _this6.preNotify();
        return _this6.matches;
      });
    });
    _this6.load = _async(function(_temp2) {
      var _ref8 = _temp2 === void 0 ? {} : _temp2, maxAge = _ref8.maxAge;
      return _this6.loadData({
        maxAge
      });
    });
    _this6.startPending = _async(function() {
      _this6.matches.forEach(function(match) {
        return match.startPending == null ? void 0 : match.startPending();
      });
      return _await();
    });
    _this6.router = router;
    _this6.location = nextLocation;
    _this6.matches = [];
    var unloadedMatches = matchRoutes(_this6.router, _this6.location);
    _this6.matches = unloadedMatches == null ? void 0 : unloadedMatches.map(function(unloadedMatch) {
      if (!_this6.router.matchCache[unloadedMatch.id]) {
        _this6.router.matchCache[unloadedMatch.id] = new RouteMatch(unloadedMatch);
      }
      return _this6.router.matchCache[unloadedMatch.id];
    });
    return _this6;
  }
  return MatchLoader2;
}(Subscribable);
function cascadeMatchData(matches) {
  matches == null ? void 0 : matches.forEach(function(match, index) {
    var _parentMatch$data;
    var parentMatch = matches == null ? void 0 : matches[index - 1];
    match.data = _extends$1({}, (_parentMatch$data = parentMatch == null ? void 0 : parentMatch.data) != null ? _parentMatch$data : {}, match.ownData);
  });
}
function useRouter() {
  var value = React.useContext(routerContext);
  if (!value) {
    warning(true, "You are trying to use useRouter() outside of ReactLocation!");
    throw new Error();
  }
  return value.router;
}
function matchRoutes(router, currentLocation) {
  if (!router.routes.length) {
    return [];
  }
  var matches = [];
  var recurse = _async(function(routes, parentMatch) {
    var _route$children3;
    var pathname = parentMatch.pathname, params = parentMatch.params;
    var filteredRoutes = router != null && router.filterRoutes ? router == null ? void 0 : router.filterRoutes(routes) : routes;
    var route = filteredRoutes.find(function(route2) {
      var _route$children2, _route$caseSensitive;
      var fullRoutePathName = joinPaths([pathname, route2.path]);
      var fuzzy = !!(route2.path !== "/" || (_route$children2 = route2.children) != null && _route$children2.length);
      var matchParams = matchRoute(currentLocation, {
        to: fullRoutePathName,
        search: route2.search,
        fuzzy,
        caseSensitive: (_route$caseSensitive = route2.caseSensitive) != null ? _route$caseSensitive : router.caseSensitive
      });
      if (matchParams) {
        params = _extends$1({}, params, matchParams);
      }
      return !!matchParams;
    });
    if (!route) {
      return;
    }
    var interpolatedPath = interpolatePath(route.path, params);
    pathname = joinPaths([pathname, interpolatedPath]);
    var interpolatedId = interpolatePath(route.id, params, true);
    var match = {
      id: interpolatedId,
      route,
      params,
      pathname,
      search: currentLocation.search
    };
    matches.push(match);
    if ((_route$children3 = route.children) != null && _route$children3.length) {
      recurse(route.children, match);
    }
    return _await();
  });
  recurse(router.routes, router.rootMatch);
  return matches;
}
function interpolatePath(path, params, leaveWildcard) {
  var interpolatedPathSegments = parsePathname(path);
  return joinPaths(interpolatedPathSegments.map(function(segment) {
    if (segment.value === "*" && !leaveWildcard) {
      return "";
    }
    if (segment.type === "param") {
      var _segment$value$substr;
      return (_segment$value$substr = params[segment.value.substring(1)]) != null ? _segment$value$substr : "";
    }
    return segment.value;
  }));
}
function useLoadRoute() {
  var location = useLocation();
  var match = useMatch();
  var router = useRouter();
  var buildNext = useBuildNext();
  return useLatestCallback(_async(function(navigate, opts) {
    var _navigate$from;
    if (navigate === void 0)
      navigate = location.current;
    var next = buildNext(_extends$1({}, navigate, {
      from: (_navigate$from = navigate.from) != null ? _navigate$from : {
        pathname: match.pathname
      }
    }));
    var matchLoader = new MatchLoader(router, next);
    return matchLoader.load(opts);
  }));
}
function useParentMatches() {
  var router = useRouter();
  var match = useMatch();
  var matches = router.state.matches;
  return matches.slice(0, matches.findIndex(function(d) {
    return d.id === match.id;
  }) - 1);
}
function useMatches() {
  return React.useContext(MatchesContext);
}
function useMatch() {
  var _useMatches;
  return (_useMatches = useMatches()) == null ? void 0 : _useMatches[0];
}
function useNavigate() {
  var location = useLocation();
  var match = useMatch();
  var buildNext = useBuildNext();
  function navigate(_ref9) {
    var _fromCurrent;
    var search = _ref9.search, hash = _ref9.hash, replace = _ref9.replace, from = _ref9.from, to = _ref9.to, fromCurrent = _ref9.fromCurrent;
    fromCurrent = (_fromCurrent = fromCurrent) != null ? _fromCurrent : typeof to === "undefined";
    var next = buildNext({
      to,
      search,
      hash,
      from: fromCurrent ? location.current : from != null ? from : {
        pathname: match.pathname
      }
    });
    location.navigate(next, replace);
  }
  return useLatestCallback(navigate);
}
function Navigate(options) {
  var navigate = useNavigate();
  useLayoutEffect2(function() {
    navigate(options);
  }, [navigate]);
  return null;
}
function useBuildNext() {
  var location = useLocation();
  var router = useRouter();
  var buildNext = function buildNext2(opts) {
    var next = location.buildNext(router.basepath, opts);
    var matches = matchRoutes(router, next);
    var __searchFilters = matches.map(function(match) {
      var _match$route$searchFi;
      return (_match$route$searchFi = match.route.searchFilters) != null ? _match$route$searchFi : [];
    }).flat().filter(Boolean);
    return location.buildNext(router.basepath, _extends$1({}, opts, {
      __searchFilters
    }));
  };
  return useLatestCallback(buildNext);
}
var Link = function Link2(_ref10) {
  var _preload;
  var _ref10$to = _ref10.to, to = _ref10$to === void 0 ? "." : _ref10$to, search = _ref10.search, hash = _ref10.hash, children = _ref10.children, target = _ref10.target, _ref10$style = _ref10.style, style = _ref10$style === void 0 ? {} : _ref10$style, replace = _ref10.replace, onClick = _ref10.onClick, onMouseEnter = _ref10.onMouseEnter, _ref10$className = _ref10.className, className = _ref10$className === void 0 ? "" : _ref10$className, _ref10$getActiveProps = _ref10.getActiveProps, getActiveProps = _ref10$getActiveProps === void 0 ? function() {
    return {};
  } : _ref10$getActiveProps, _ref10$getInactivePro = _ref10.getInactiveProps, getInactiveProps = _ref10$getInactivePro === void 0 ? function() {
    return {};
  } : _ref10$getInactivePro, activeOptions = _ref10.activeOptions, preload = _ref10.preload, disabled = _ref10.disabled, _ref = _ref10._ref, rest = _objectWithoutPropertiesLoose(_ref10, _excluded4);
  var loadRoute = useLoadRoute();
  var match = useMatch();
  var location = useLocation();
  var router = useRouter();
  var navigate = useNavigate();
  var buildNext = useBuildNext();
  preload = (_preload = preload) != null ? _preload : router.defaultLinkPreloadMaxAge;
  try {
    var url = new URL("" + to);
    warning(false, "<Link /> should not be used for external URLs like: " + url.href);
  } catch (e) {
  }
  var next = buildNext({
    to,
    search,
    hash,
    from: {
      pathname: match.pathname
    }
  });
  var handleClick = function handleClick2(e) {
    if (onClick)
      onClick(e);
    if (!isCtrlEvent(e) && !e.defaultPrevented && (!target || target === "_self") && e.button === 0) {
      e.preventDefault();
      navigate({
        to,
        search,
        hash,
        replace,
        from: {
          pathname: match.pathname
        }
      });
    }
  };
  var handleMouseEnter = function handleMouseEnter2(e) {
    if (onMouseEnter)
      onMouseEnter(e);
    if (preload && preload > 0) {
      loadRoute({
        to,
        search,
        hash
      }, {
        maxAge: preload
      });
    }
  };
  var pathIsEqual = location.current.pathname === next.pathname;
  var currentPathSplit = location.current.pathname.split("/");
  var nextPathSplit = next.pathname.split("/");
  var pathIsFuzzyEqual = nextPathSplit.every(function(d, i) {
    return d === currentPathSplit[i];
  });
  var hashIsEqual = location.current.hash === next.hash;
  var pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;
  var hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true;
  var isActive = pathTest && hashTest;
  var _ref11 = isActive ? getActiveProps() : {}, _ref11$style = _ref11.style, activeStyle = _ref11$style === void 0 ? {} : _ref11$style, _ref11$className = _ref11.className, activeClassName = _ref11$className === void 0 ? "" : _ref11$className, activeRest = _objectWithoutPropertiesLoose(_ref11, _excluded5);
  var _ref12 = isActive ? {} : getInactiveProps(), _ref12$style = _ref12.style, inactiveStyle = _ref12$style === void 0 ? {} : _ref12$style, _ref12$className = _ref12.className, inactiveClassName = _ref12$className === void 0 ? "" : _ref12$className, inactiveRest = _objectWithoutPropertiesLoose(_ref12, _excluded6);
  return React.createElement("a", _extends$1({
    ref: _ref,
    href: disabled ? void 0 : next.href,
    onClick: handleClick,
    onMouseEnter: handleMouseEnter,
    target,
    style: _extends$1({}, style, activeStyle, inactiveStyle),
    className: [className, activeClassName, inactiveClassName].filter(Boolean).join(" ") || void 0
  }, disabled ? {
    role: "link",
    "aria-disabled": true
  } : void 0, rest, activeRest, inactiveRest, {
    children: typeof children === "function" ? children({
      isActive
    }) : children
  }));
};
function Outlet() {
  var _match$errorElement;
  var router = useRouter();
  var _useMatches2 = useMatches();
  _useMatches2[0];
  var matches = _useMatches2.slice(1);
  var match = matches[0];
  if (!match) {
    return null;
  }
  var errorElement = (_match$errorElement = match.errorElement) != null ? _match$errorElement : router.defaultErrorElement;
  var element = function() {
    var _match$pendingElement, _match$element;
    if (match.status === "rejected") {
      if (errorElement) {
        return errorElement;
      }
      if (!router.useErrorBoundary) {
        if (true) {
          var preStyle = {
            whiteSpace: "normal",
            display: "inline-block",
            background: "rgba(0,0,0,.1)",
            padding: ".1rem .2rem",
            margin: ".1rem",
            lineHeight: "1",
            borderRadius: ".25rem"
          };
          return React.createElement("div", {
            style: {
              lineHeight: "1.7"
            }
          }, React.createElement("strong", null, "The following error occured in the loader for you route at:", " ", React.createElement("pre", {
            style: preStyle
          }, match.pathname)), ".", React.createElement("br", null), React.createElement("pre", {
            style: _extends$1({}, preStyle, {
              display: "block",
              padding: ".5rem",
              borderRadius: ".5rem"
            })
          }, match.error.toString()), React.createElement("br", null), "Your users won't see this message in production, but they will see", " ", React.createElement("strong", null, '"An unknown error occured!"'), ", which is at least better than breaking your entire app. \u{1F60A} For a better UX, please specify an ", React.createElement("pre", {
            style: preStyle
          }, "errorElement"), " for all of your routes that contain asynchronous behavior, or at least provide your own", React.createElement("pre", {
            style: preStyle
          }, "ErrorBoundary"), " wrapper around your renders to both the elements rendered by", " ", React.createElement("pre", {
            style: preStyle
          }, "useRoutes(routes, { useErrorBoundary: true })"), " ", "and ", React.createElement("pre", {
            style: preStyle
          }, "<Router useErrorBoundary />"), ".", " ", React.createElement("br", null), React.createElement("br", null));
        }
        return "An unknown error occured!";
      }
      throw match.error;
    }
    var pendingElement = (_match$pendingElement = match.pendingElement) != null ? _match$pendingElement : router.defaultPendingElement;
    if (match.status === "loading") {
      return null;
    }
    if (match.status === "pending") {
      if (match.route.pendingMs || pendingElement) {
        return pendingElement != null ? pendingElement : null;
      }
    }
    var matchElement = (_match$element = match.element) != null ? _match$element : router.defaultElement;
    return matchElement != null ? matchElement : React.createElement(Outlet, null);
  }();
  return React.createElement(MatchesProvider, {
    value: matches
  }, element);
}
function useResolvePath() {
  var router = useRouter();
  var match = useMatch();
  return useLatestCallback(function(path) {
    return resolvePath(router.basepath, match.pathname, cleanPath(path));
  });
}
function useSearch() {
  var location = useLocation();
  return location.current.search;
}
function matchRoute(currentLocation, matchLocation) {
  var pathParams = matchByPath(currentLocation, matchLocation);
  var searchMatched = matchBySearch(currentLocation, matchLocation);
  if (matchLocation.to && !pathParams) {
    return;
  }
  if (matchLocation.search && !searchMatched) {
    return;
  }
  return pathParams != null ? pathParams : {};
}
function useMatchRoute() {
  var router = useRouter();
  var resolvePath2 = useResolvePath();
  return useLatestCallback(function(_ref13) {
    var pending = _ref13.pending, matchLocation = _objectWithoutPropertiesLoose(_ref13, _excluded7);
    matchLocation = _extends$1({}, matchLocation, {
      to: matchLocation.to ? resolvePath2("" + matchLocation.to) : void 0
    });
    if (pending) {
      var _router$pending;
      if (!((_router$pending = router.pending) != null && _router$pending.location)) {
        return void 0;
      }
      return matchRoute(router.pending.location, matchLocation);
    }
    return matchRoute(router.state.location, matchLocation);
  });
}
function MatchRoute(_ref14) {
  var children = _ref14.children, rest = _objectWithoutPropertiesLoose(_ref14, _excluded8);
  var matchRoute2 = useMatchRoute();
  var match = matchRoute2(rest);
  if (typeof children === "function") {
    return children(match);
  }
  return match ? children : null;
}
function usePrompt(message, when) {
  var location = useLocation();
  React.useEffect(function() {
    if (!when)
      return;
    var unblock = location.history.block(function(transition) {
      if (window.confirm(message)) {
        unblock();
        transition.retry();
      } else {
        location.current.pathname = window.location.pathname;
      }
    });
    return unblock;
  }, [when, location, message]);
}
function Prompt(_ref15) {
  var message = _ref15.message, when = _ref15.when, children = _ref15.children;
  usePrompt(message, when != null ? when : true);
  return children != null ? children : null;
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (_unused) {
    }
  }
}
function isFunction(d) {
  return typeof d === "function";
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
function joinPaths(paths) {
  return cleanPath(paths.filter(Boolean).join("/"));
}
function cleanPath(path) {
  return ("" + path).replace(/\/{2,}/g, "/");
}
function matchByPath(currentLocation, matchLocation) {
  var _matchLocation$to;
  var baseSegments = parsePathname(currentLocation.pathname);
  var routeSegments = parsePathname("" + ((_matchLocation$to = matchLocation.to) != null ? _matchLocation$to : "*"));
  var params = {};
  var isMatch = function() {
    for (var i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      var baseSegment = baseSegments[i];
      var routeSegment = routeSegments[i];
      var isLastRouteSegment = i === routeSegments.length - 1;
      var isLastBaseSegment = i === baseSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          if (baseSegment != null && baseSegment.value) {
            params["*"] = joinPaths(baseSegments.slice(i).map(function(d) {
              return d.value;
            }));
            return true;
          }
          return false;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !(baseSegment != null && baseSegment.value)) {
            return true;
          }
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
          }
        }
        if (!baseSegment) {
          return false;
        }
        if (routeSegment.type === "param") {
          params[routeSegment.value.substring(1)] = baseSegment.value;
        }
      }
      if (isLastRouteSegment && !isLastBaseSegment) {
        return !!matchLocation.fuzzy;
      }
    }
    return true;
  }();
  return isMatch ? params : void 0;
}
function matchBySearch(currentLocation, matchLocation) {
  return !!(matchLocation.search && matchLocation.search(currentLocation.search));
}
function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }
  pathname = cleanPath(pathname);
  var segments = [];
  if (pathname.slice(0, 1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  if (!pathname) {
    return segments;
  }
  var split = pathname.split("/").filter(Boolean);
  segments.push.apply(segments, split.map(function(part) {
    if (part.startsWith("*")) {
      return {
        type: "wildcard",
        value: part
      };
    }
    if (part.charAt(0) === ":") {
      return {
        type: "param",
        value: part
      };
    }
    return {
      type: "pathname",
      value: part
    };
  }));
  if (pathname.slice(-1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  return segments;
}
function resolvePath(basepath, base, to) {
  base = base.replace(new RegExp("^" + basepath), "/");
  to = to.replace(new RegExp("^" + basepath), "/");
  var baseSegments = parsePathname(base);
  var toSegments = parsePathname(to);
  toSegments.forEach(function(toSegment, index) {
    if (toSegment.value === "/") {
      if (!index) {
        baseSegments = [toSegment];
      } else if (index === toSegments.length - 1) {
        baseSegments.push(toSegment);
      } else
        ;
    } else if (toSegment.value === "..") {
      baseSegments.pop();
    } else if (toSegment.value === ".") {
      return;
    } else {
      baseSegments.push(toSegment);
    }
  });
  var joined = joinPaths([basepath].concat(baseSegments.map(function(d) {
    return d.value;
  })));
  return cleanPath(joined);
}
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function useLatestCallback(cb) {
  var stableFnRef = React.useRef();
  var cbRef = React.useRef(cb);
  cbRef.current = cb;
  if (!stableFnRef.current) {
    stableFnRef.current = function() {
      return cbRef.current.apply(cbRef, arguments);
    };
  }
  return stableFnRef.current;
}
function replaceEqualDeep(prev, next) {
  if (prev === next) {
    return prev;
  }
  var array = Array.isArray(prev) && Array.isArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    var aSize = array ? prev.length : Object.keys(prev).length;
    var bItems = array ? next : Object.keys(next);
    var bSize = bItems.length;
    var copy = array ? [] : {};
    var equalItems = 0;
    for (var i = 0; i < bSize; i++) {
      var key = array ? i : bItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);
      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? prev : copy;
  }
  return next;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  var ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  var prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function defaultStringifySearch(search) {
  search = _extends$1({}, search);
  if (search) {
    Object.keys(search).forEach(function(key) {
      var val = search[key];
      if (typeof val === "undefined" || val === void 0) {
        delete search[key];
      } else if (val && typeof val === "object" && val !== null) {
        try {
          search[key] = JSON.stringify(val);
        } catch (err) {
        }
      }
    });
  }
  var searchStr = new URLSearchParams(search).toString();
  return searchStr ? "?" + searchStr : "";
}
function defaultParseSearch(searchStr) {
  if (searchStr.substring(0, 1) === "?") {
    searchStr = searchStr.substring(1);
  }
  var query = Object.fromEntries(new URLSearchParams(searchStr).entries());
  for (var key in query) {
    var value = query[key];
    try {
      query[key] = JSON.parse(value);
    } catch (err) {
    }
  }
  return query;
}
export {
  Link,
  MatchRoute,
  MatchesProvider,
  Navigate,
  Outlet,
  Prompt,
  ReactLocation,
  RouteMatch,
  Router,
  RouterInstance,
  cleanPath,
  createBrowserHistory,
  createHashHistory,
  createMemoryHistory,
  defaultParseSearch,
  defaultStringifySearch,
  functionalUpdate,
  matchByPath,
  matchRoute,
  matchRoutes,
  parsePathname,
  resolvePath,
  useLoadRoute,
  useLocation,
  useMatch,
  useMatchRoute,
  useMatches,
  useNavigate,
  useParentMatches,
  usePrompt,
  useResolvePath,
  useRouter,
  useSearch
};
/**
 * react-location
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
//# sourceMappingURL=react-location.js.map
